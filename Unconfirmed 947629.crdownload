import os
import sys
import subprocess
import csv
import hashlib

# --- Configuration ---
TODO_FILENAME = "TODO.md"
TRACKING_FILE = "jules_tasks.csv"
GIT_REMOTE_NAME = "origin"  # Usually 'origin'
MAIN_BRANCH_NAME = "main"   # Or 'master'
JULES_EXECUTABLE_PATH = "C:/Users/power/AppData/Roaming/npm/jules.cmd" # Your full path
# --- End Configuration ---

#==============================================================================
# SECTION 1: PARSING AND JULES INTERACTION
#==============================================================================

def parse_structured_todo(filename: str) -> dict[str, str]:
    """
    Parses the TODO.md and returns a dictionary of {prompt_hash: full_prompt}.
    This prevents re-creating tasks that are already being tracked.
    """
    prompts = {}
    # ... (This function's logic is the same as before, but returns a dict)
    try:
        with open(filename, "r", encoding="utf-8") as f: lines = f.readlines()
    except FileNotFoundError: return {}
    in_pending_section, is_capturing_task, current_task_lines = False, False, []
    for line in lines:
        stripped_line = line.strip()
        if stripped_line.startswith('## **Pending Tasks**'): in_pending_section = True; continue
        elif stripped_line.startswith('## **Completed Tasks**'): in_pending_section = False; continue
        if not in_pending_section: continue
        if stripped_line == '---':
            if current_task_lines:
                prompt = "\n".join(current_task_lines)
                prompt_hash = hashlib.sha256(prompt.encode()).hexdigest()
                prompts[prompt_hash] = prompt
                current_task_lines = []
            is_capturing_task = False; continue
        if stripped_line == '- **Task:**': is_capturing_task = True; continue
        if is_capturing_task and stripped_line: current_task_lines.append(stripped_line)
    if current_task_lines:
        prompt = "\n".join(current_task_lines)
        prompt_hash = hashlib.sha256(prompt.encode()).hexdigest()
        prompts[prompt_hash] = prompt
    return prompts

def create_jules_task_with_cli(prompt: str) -> str | None:
    """Calls the Jules CLI. If successful, it parses and returns the session ID."""
    # ... (This function is unchanged)
    print("---")
    print(f"-> Creating task for prompt:\n{prompt}\n")
    try:
        command = [JULES_EXECUTABLE_PATH, "remote", "new", "--repo", ".", "--session", prompt]
        result = subprocess.run(command, capture_output=True, text=True, check=True)
        session_id = None
        for line in result.stdout.splitlines():
            if "Session created:" in line: session_id = line.split(":")[-1].strip()
        if session_id: print(f"--> Success! Found Session ID: {session_id}"); return session_id
        else: print("--> Task created, but could not parse Session ID from output."); return None
    except Exception as e: print(f"--> Failed to create task. Error: {e}"); return None

def get_jules_task_status(session_id: str) -> str | None:
    """Checks the status of a Jules session using the CLI."""
    # ... (This function is unchanged)
    try:
        command = [JULES_EXECUTABLE_PATH, "remote", "get", session_id]
        result = subprocess.run(command, capture_output=True, text=True, check=True)
        for line in result.stdout.splitlines():
            if line.lower().startswith("status:"): return line.split(":")[-1].strip().upper()
        return "UNKNOWN"
    except subprocess.CalledProcessError: return "ERROR" # Assuming error means not complete
    except FileNotFoundError: return "ERROR"

#==============================================================================
# SECTION 2: FILE AND GIT MANIPULATION
#==============================================================================

def update_todo_for_completion(full_prompt_text: str) -> bool:
    """
    Safely updates the TODO.md by commenting out a completed pending task
    and appending it to the completed section.
    """
    print(f"  - Updating {TODO_FILENAME} to mark task as complete...")
    try:
        with open(TODO_FILENAME, 'r', encoding='utf-8') as f: lines = f.readlines()

        # Find the full block of the original task
        original_text = ""
        # This is a simplified search; assumes the prompt is unique enough
        for line in lines:
            if full_prompt_text in line: # A simple check
                # A more robust parser would be needed for complex cases
                original_text = full_prompt_text # Placeholder for a real block search
                break

        # For safety, we will just append to the completed section
        # and let the user manually clean up the pending section.
        # This is the safest approach to avoid corrupting the file.
        completed_block = f"---\n\n### **[AUTO-COMPLETED]**\n- **Status:** Complete\n- **Task:**\n{full_prompt_text}\n"

        completed_section_index = -1
        for i, line in enumerate(lines):
            if line.strip().startswith('## **Completed Tasks**'):
                completed_section_index = i
                break

        if completed_section_index != -1:
            lines.insert(completed_section_index + 1, completed_block)
            with open(TODO_FILENAME, 'w', encoding='utf-8') as f:
                f.writelines(lines)
            print("  - Successfully updated TODO.md.")
            return True
        else:
            print("  - ERROR: Could not find '## **Completed Tasks**' section in TODO.md.")
            return False
    except Exception as e:
        print(f"  - ERROR: Failed to write to {TODO_FILENAME}: {e}")
        return False

def create_pull_request(session_id: str, prompt_hash: str):
    """Creates a new branch, commits the updated TODO, pushes, and creates a PR."""
    print("  - Starting Git process to create a Pull Request...")
    branch_name = f"docs/complete-task-{session_id}"
    commit_message = f"docs: Mark task as complete\n\nAssociated Jules Session: {session_id}"

    try:
        # Create and switch to a new branch
        subprocess.run(["git", "checkout", "-b", branch_name], check=True)

        # Stage the updated TODO file
        subprocess.run(["git", "add", TODO_FILENAME], check=True)

        # Commit the changes
        subprocess.run(["git", "commit", "-m", commit_message], check=True)

        # Push the new branch to the remote
        print(f"  - Pushing branch '{branch_name}' to remote...")
        subprocess.run(["git", "push", GIT_REMOTE_NAME, branch_name], check=True)

        # Create the pull request using the GitHub CLI
        print("  - Creating Pull Request on GitHub...")
        pr_title = f"Docs: Mark task {session_id} as complete"
        pr_body = f"This PR automatically updates `TODO.md` after verifying that Jules session `{session_id}` is complete."
        subprocess.run(["gh", "pr", "create", "--title", pr_title, "--body", pr_body], check=True)

        print("  - Successfully created Pull Request!")

    except (subprocess.CalledProcessError, FileNotFoundError) as e:
        print(f"  - GIT/GH ERROR: An error occurred: {e}")
        print("  - Cleaning up local branch...")
        subprocess.run(["git", "checkout", MAIN_BRANCH_NAME])
        subprocess.run(["git", "branch", "-D", branch_name]) # Force delete local branch
    finally:
        # Always switch back to the main branch
        subprocess.run(["git", "checkout", MAIN_BRANCH_NAME])

#==============================================================================
# SECTION 3: MAIN WORKFLOWS (MODES)
#==============================================================================

def run_create_mode():
    """Parses TODO, finds new tasks, and sends them to Jules."""
    print("Running in CREATE mode...")

    # Get tasks currently in the TODO file
    tasks_in_todo = parse_structured_todo(TODO_FILENAME)
    if not tasks_in_todo:
        print("No pending tasks found in TODO.md.")
        return

    # Get tasks we are already tracking
    tracked_tasks = {}
    if os.path.exists(TRACKING_FILE):
        with open(TRACKING_FILE, 'r', newline='') as f:
            reader = csv.reader(f)
            for row in reader:
                tracked_tasks[row[0]] = row[1] # {hash: session_id}

    # Figure out which tasks are new
    new_tasks_to_create = {h: p for h, p in tasks_in_todo.items() if h not in tracked_tasks}

    if not new_tasks_to_create:
        print("All pending tasks in TODO.md are already being tracked.")
        return

    print(f"Found {len(new_tasks_to_create)} new tasks to create.")

    created_tasks_log = []
    for prompt_hash, prompt in new_tasks_to_create.items():
        session_id = create_jules_task_with_cli(prompt)
        if session_id:
            created_tasks_log.append([prompt_hash, session_id, prompt])

    if created_tasks_log:
        with open(TRACKING_FILE, 'a', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerows(created_tasks_log)
        print(f"\nSuccessfully tracked {len(created_tasks_log)} new tasks in {TRACKING_FILE}.")

def run_review_mode():
    """Checks tracked tasks, and if complete, updates TODO and creates a PR."""
    print("Running in REVIEW mode...")
    if not os.path.exists(TRACKING_FILE):
        print(f"Tracking file '{TRACKING_FILE}' not found. Nothing to review.")
        return

    with open(TRACKING_FILE, 'r', newline='', encoding='utf-8') as f:
        reader = csv.reader(f)
        all_tasks = list(reader)

    still_pending_tasks = []
    has_completed_a_task = False

    for prompt_hash, session_id, full_prompt in all_tasks:
        print(f"- Checking task {session_id}...")
        status = get_jules_task_status(session_id)
        print(f"  - Status: {status}")

        if status in ['COMPLETE', 'COMPLETED']:
            print(f"  - Task {session_id} is complete! Starting completion workflow...")
            has_completed_a_task = True
            if update_todo_for_completion(full_prompt):
                create_pull_request(session_id, prompt_hash)
            # If complete, we DON'T add it back to the pending list
        else:
            still_pending_tasks.append([prompt_hash, session_id, full_prompt])

    # Rewrite the tracking file with only the tasks that are still pending
    with open(TRACKING_FILE, 'w', newline='', encoding='utf-8') as f:
        writer = csv.writer(f)
        writer.writerows(still_pending_tasks)

    if not has_completed_a_task:
        print("\nNo tasks were completed since the last review.")

    print(f"\nReview complete. {len(still_pending_tasks)} tasks remain pending.")

#==============================================================================
# SCRIPT ENTRYPOINT
#==============================================================================

if __name__ == "__main__":
    if len(sys.argv) < 2 or sys.argv[1] not in ['create', 'review']:
        print("Usage: python agent_controller.py [mode]")
        print("Modes:")
        print("  create   - Creates Jules tasks for new items in TODO.md")
        print("  review   - Reviews tracked tasks, and if complete, updates TODO and creates a PR")
        sys.exit(1)

    mode = sys.argv[1]

    if mode == "create":
        run_create_mode()
    elif mode == "review":
        run_review_mode()

    print("\nScript finished.")